# Anagram-Solver
There are a number of ways in which this can be done.  A naive, brute-force approach would be to take each word in the dictionary, take all permutations of its letters, and determine that it is an anagram if one of those permutations matches the given word.  A slight improvement to this would be to take all permutations of the given input word, and linearly search the dictionary for those permutations.  The performance of either approach would be below poor, because there are n! permutations of a word of n letters.  Moreover, linear search could be improved slightly (although this would be rather unhelpful in the face of a factorial algorithm such as this) by first sorting the list in (n log n) time for an n-word dictionary, enabling logarithmic-time binary search of the list.

Approach

One possibly better approach to solving this problem is to create a data structure that hashes the sum of the values of the letters you have in your word.  Even this may not be ideal to simply assign the letter A to 1, B to 2, C to 3, and so on, because the "word" GHI would hash to the number 7+8+9 = 24.  However, the "word" HHH would also hash to 8+8+8 = 24, but would be a different word.  Although this is allowed with hash tables that handle collisions via, say, a linked list of possible matches, we could also enable unique hashing in this situation.  One way we do this is similar to a "bitmask," in which each bit of a 32-bit number represents a different letter.  In other words, A = 1, B = 2, C = 4, D = 8, and so on, until Z = 225.  However, this would limit the maximum length of our word somewhat, as a 32-integer can only hold values up to 232 in total.

Thus, we will hash our words such that A = 1, B = 2, C = 3, and so on.  The position of the letter in the word is irrelevant, since we will consider permutations of the word.  Moreover, the case of the letter will be irrelevant in this problem as well, so the value of a = the value of A = 1.  You will create a hash table data structure that maps integers (the sum of the letters in the word) to a linked list of char* (each char* being a string that represents the matching word).

Using this approach, you can iterate over each word in the dictionary, compute its "hash value," and add the word to the appropriate linked list that corresponds to that hash value.  You will malloc each hash entry, and each linked list within the hash entry; further, you should maintain your hash entries in sorted order so that it can be searched in binary time.

Once you have this, your search space will be greatly reduced.  Once you have your input word, you can compute its "hash value" as well, and then search that linked list in the hash table for your anagrams.  Be sure to validate that each word in the linked list is indeed an anagram (has the same length as the input word and uses each letter of the input word exactly once), as you'll recall above that some words with the same hash value may represent "false positives."

Optional optimizations are also possible, such as maintaining an array of these hash tables, indexed by the length of the word.  This is because we know automatically that a word cannot be an anagram of another word if the words are not of the same length.  Thus, we can search those separately and reduce the search space further.

Note that, in this way, you will still need to check for anagrams for each word that matches the hash, becuase there will be some "false positives."  You might sort the letters in each word to help verify that they are, indeed, anagrams.
